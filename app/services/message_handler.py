# Enhanced Message Handler for LINE Bot with Gemini AI Integration
"""
Comprehensive message handler that processes different LINE message types
and routes them to appropriate Gemini AI tools for intelligent responses.

Supported Message Types:
- Text messages
- Sticker messages  
- Image messages
- Video messages
- Audio messages
- Location messages
- Imagemap messages
- Template messages
- Flex messages
- Carousel flex messages
- Quick reply
"""

import json
import asyncio
from datetime import datetime
from typing import Dict, Optional, Any, Union
from sqlalchemy.ext.asyncio import AsyncSession

from linebot.v3.messaging import (
    AsyncMessagingApi, AsyncMessagingApiBlob, TextMessage, StickerMessage,
    ReplyMessageRequest, PushMessageRequest
    # ShowLoadingAnimationRequest removed for compatibility
)
from linebot.v3.webhooks import (
    MessageEvent, TextMessageContent, ImageMessageContent, VideoMessageContent,
    AudioMessageContent, FileMessageContent, LocationMessageContent, 
    StickerMessageContent, PostbackEvent
)

from app.core.config import settings
from app.db.crud import get_or_create_user_status, save_chat_message
from app.db.crud_enhanced import save_chat_to_history, log_system_event
from app.services.gemini_service import (
    get_ai_response, image_understanding, document_understanding, 
    check_gemini_availability
)
from app.services.fast_gemini_service import (
    get_ai_response_fast, check_gemini_availability as check_fast_gemini,
    get_gemini_status
)
from app.services.line_handler_enhanced import (
    get_user_profile_enhanced, send_telegram_notification_enhanced
)

class MessageHandler:
    """Advanced message handler with Gemini AI integration"""
    
    def __init__(self):
        self.supported_types = {
            'text': self.handle_text_message,
            'image': self.handle_image_message,
            'video': self.handle_video_message,
            'audio': self.handle_audio_message,
            'file': self.handle_file_message,
            'location': self.handle_location_message,
            'sticker': self.handle_sticker_message,
            'postback': self.handle_postback_message,
            'quick_reply': self.handle_quick_reply_message,
            'imagemap': self.handle_imagemap_message,
            'template': self.handle_template_message,
            'flex': self.handle_flex_message,
            'carousel_flex': self.handle_carousel_flex_message
        }
    
    async def process_message(self, event: MessageEvent, db: AsyncSession, line_bot_api: AsyncMessagingApi) -> bool:
        """
        Main entry point for processing all message types
        
        Args:
            event: LINE webhook event
            db: Database session
            line_bot_api: LINE messaging API client
            
        Returns:
            bool: Success status
        """
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            
            # Get user profile
            profile_data = await get_user_profile_enhanced(line_bot_api, user_id)
            
            # Determine message type
            message_type = self._detect_message_type(event)
            
            # Log incoming message
            await log_system_event(
                db=db,
                level="info",
                category="message_handler",
                subcategory="message_received",
                message=f"Processing {message_type} message from {profile_data['display_name']}",
                user_id=user_id,
                details={"message_type": message_type, "profile": profile_data}
            )
            
            # Route to appropriate handler
            if message_type in self.supported_types:
                handler = self.supported_types[message_type]
                success = await handler(event, db, line_bot_api, profile_data)
                
                if success:
                    await log_system_event(
                        db=db, level="info", category="message_handler", 
                        subcategory="message_processed",
                        message=f"Successfully processed {message_type} message",
                        user_id=user_id
                    )
                return success
            else:
                # Unsupported message type
                await self._handle_unsupported_message(event, db, line_bot_api, profile_data, message_type)
                return True
                
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="processing_error",
                message=f"Error processing message: {str(e)}",
                user_id=getattr(event.source, 'user_id', 'unknown')
            )
            return False
    
    def _detect_message_type(self, event: MessageEvent) -> str:
        """Detect the type of incoming message"""
        if hasattr(event, 'message'):
            if isinstance(event.message, TextMessageContent):
                return 'text'
            elif isinstance(event.message, ImageMessageContent):
                return 'image'
            elif isinstance(event.message, VideoMessageContent):
                return 'video'
            elif isinstance(event.message, AudioMessageContent):
                return 'audio'
            elif isinstance(event.message, FileMessageContent):
                return 'file'
            elif isinstance(event.message, LocationMessageContent):
                return 'location'
            elif isinstance(event.message, StickerMessageContent):
                return 'sticker'
        
        if isinstance(event, PostbackEvent):
            return 'postback'
        
        # Check for special message types in message content
        if hasattr(event, 'message') and hasattr(event.message, 'type'):
            msg_type = event.message.type
            if msg_type in ['imagemap', 'template', 'flex']:
                return msg_type
        
        return 'unknown'

    async def handle_text_message(self, event: MessageEvent, db: AsyncSession, 
                                line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle text messages with advanced AI processing"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            message_text = event.message.text
            session_id = f"session_{user_id}_{datetime.now().strftime('%Y%m%d')}"
            
            # Save user message
            await save_chat_to_history(
                db=db, user_id=user_id, message_type='user', 
                message_content=message_text, session_id=session_id,
                extra_data={"profile_data": profile_data, "message_type": "text"}
            )
            await save_chat_message(db, user_id, 'user', message_text)
            
            # Broadcast to admin panel via WebSocket
            from app.services.ws_manager import manager
            from app.utils.timezone import get_thai_time
            
            thai_time = get_thai_time()
            await manager.broadcast({
                "type": "new_message", 
                "userId": user_id, 
                "message": message_text,
                "displayName": profile_data.get('display_name', f"Customer {user_id[-6:]}"),
                "pictureUrl": profile_data.get('picture_url'),
                "sessionId": session_id, 
                "timestamp": thai_time.isoformat()
            })
            
            # Show loading animation
            await self._show_loading_animation(line_bot_api, user_id)
            
            # Special command handling
            if await self._handle_special_commands(message_text, event, db, line_bot_api, profile_data):
                return True
            
            # Get AI response using Fast Gemini Service
            gemini_available = await check_fast_gemini()
            
            if gemini_available:
                try:
                    print(f"üöÄ Using Fast Gemini for user {user_id}: {message_text[:50]}...")
                    
                    # Use fast AI response with optimized context
                    context = f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {profile_data.get('display_name', '‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤')}"
                    ai_response = await get_ai_response_fast(
                        message=message_text,
                        context=context
                    )
                    
                    print(f"‚úÖ Fast AI response received in minimal time")
                    
                    # Reply with AI response
                    await line_bot_api.reply_message(
                        ReplyMessageRequest(
                            reply_token=reply_token,
                            messages=[TextMessage(text=ai_response)]
                        )
                    )
                    
                    # Save AI response
                    await save_chat_to_history(
                        db=db, user_id=user_id, message_type='ai_bot',
                        message_content=ai_response, session_id=session_id,
                        extra_data={"ai_powered": True, "fast_gemini": True, "original_message": message_text}
                    )
                    await save_chat_message(db, user_id, 'ai_bot', ai_response)
                    
                    # Broadcast AI response to admin panel
                    await manager.broadcast({
                        "type": "bot_auto_reply", 
                        "userId": user_id, 
                        "message": ai_response, 
                        "sessionId": session_id
                    })
                    
                except Exception as e:
                    # Fallback response
                    fallback_response = "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö AI ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà"
                    await line_bot_api.reply_message(
                        ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=fallback_response)])
                    )
                    
                    await log_system_event(
                        db=db, level="warning", category="gemini", subcategory="ai_fallback",
                        message=f"AI response failed: {str(e)}", user_id=user_id
                    )
            else:
                # AI unavailable fallback
                fallback_response = "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞! ‡∏î‡∏µ‡πÉ‡∏à‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ô‡∏∞‡∏Ñ‡∏∞ üòä ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡πÇ‡∏õ‡∏£‡∏î‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà' ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡πà‡∏∞"
                await line_bot_api.reply_message(
                    ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=fallback_response)])
                )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="text_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_image_message(self, event: MessageEvent, db: AsyncSession,
                                 line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle image messages with AI vision analysis"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            message_id = event.message.id
            session_id = f"img_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Save image message log
            await save_chat_to_history(
                db=db, user_id=user_id, message_type='user_image',
                message_content=f"‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û (ID: {message_id})",
                session_id=session_id,
                extra_data={"message_id": message_id, "content_type": "image", "profile_data": profile_data}
            )
            await save_chat_message(db, user_id, 'user', f"[‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û] ID: {message_id}")
            
            # Show loading animation
            await self._show_loading_animation(line_bot_api, user_id, 5)
            
            try:
                # Download image content
                blob_api = await self._get_blob_api()
                image_content = await blob_api.get_message_content(message_id=message_id)
                
                # Analyze with Gemini Vision
                analysis_prompt = f"‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠ {profile_data['display_name']} ‡πÇ‡∏î‡∏¢‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡πá‡∏ô‡πÉ‡∏ô‡∏†‡∏≤‡∏û ‡∏™‡∏µ‡∏™‡∏±‡∏ô ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡πÅ‡∏•‡∏∞‡∏ö‡∏£‡∏¥‡∏ö‡∏ó‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç"
                
                ai_response = await image_understanding(image_content, analysis_prompt)
                
                # Reply with analysis
                await line_bot_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=reply_token,
                        messages=[TextMessage(text=f"üì∏ ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û:\n\n{ai_response}")]
                    )
                )
                
                # Save AI analysis
                await save_chat_to_history(
                    db=db, user_id=user_id, message_type='ai_image_analysis',
                    message_content=ai_response, session_id=session_id,
                    extra_data={"message_id": message_id, "ai_powered": True, "analysis_type": "image_vision"}
                )
                await save_chat_message(db, user_id, 'ai_bot', f"[‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û] {ai_response}")
                
                # Notify admin
                await send_telegram_notification_enhanced(
                    db=db, notification_type="image_analysis", 
                    title="üì∏ ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÅ‡∏•‡πâ‡∏ß",
                    message=f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {profile_data['display_name']}\n‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå: {ai_response[:100]}...",
                    user_id=user_id, priority=2,
                    data={"message_id": message_id, "analysis": ai_response}
                )
                
            except Exception as e:
                error_response = "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á"
                await line_bot_api.reply_message(
                    ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=error_response)])
                )
                
                await log_system_event(
                    db=db, level="error", category="gemini", subcategory="image_analysis_failed",
                    message=f"Image analysis failed: {str(e)}", user_id=user_id
                )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="image_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_video_message(self, event: MessageEvent, db: AsyncSession,
                                 line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle video messages with metadata analysis"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            message_id = event.message.id
            duration = getattr(event.message, 'duration', 0)
            
            # Save video message log
            await save_chat_to_history(
                db=db, user_id=user_id, message_type='user_video',
                message_content=f"‡∏™‡πà‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ (ID: {message_id}, ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤: {duration}ms)",
                session_id=f"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                extra_data={"message_id": message_id, "duration": duration, "content_type": "video"}
            )
            
            # Video processing response
            response_text = f"üìπ ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠!\n\n‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤ {duration/1000:.1f} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÅ‡∏•‡πâ‡∏ß"
            
            if duration > 30000:  # > 30 seconds
                response_text += "\n\n‚ö†Ô∏è ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ó‡∏µ‡πà‡∏¢‡∏≤‡∏ß‡∏Å‡∏ß‡πà‡∏≤ 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏≠‡∏≤‡∏à‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ô‡∏≤‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô"
            
            response_text += "\n\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡∏î‡∏π‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà'"
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
            )
            
            # Notify admin about video
            await send_telegram_notification_enhanced(
                db=db, notification_type="video_received",
                title="üìπ ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÉ‡∏´‡∏°‡πà",
                message=f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {profile_data['display_name']}\n‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤: {duration/1000:.1f} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ",
                user_id=user_id, priority=2,
                data={"message_id": message_id, "duration": duration}
            )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="video_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_audio_message(self, event: MessageEvent, db: AsyncSession,
                                 line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle audio messages with transcription suggestions"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            message_id = event.message.id
            duration = getattr(event.message, 'duration', 0)
            
            # Save audio message log
            await save_chat_to_history(
                db=db, user_id=user_id, message_type='user_audio',
                message_content=f"‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á (ID: {message_id}, ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤: {duration}ms)",
                session_id=f"audio_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                extra_data={"message_id": message_id, "duration": duration, "content_type": "audio"}
            )
            
            # Audio processing response
            response_text = f"üéµ ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á!\n\n‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤ {duration/1000:.1f} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÅ‡∏•‡πâ‡∏ß"
            
            if duration > 60000:  # > 1 minute
                response_text += "\n\nüí° ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Ñ‡πà‡∏≠‡∏ô‡∏Ç‡πâ‡∏≤‡∏á‡∏¢‡∏≤‡∏ß ‡∏´‡∏≤‡∏Å‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏±‡πâ‡∏ô‡πÜ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö"
            
            response_text += "\n\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà'"
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
            )
            
            # Notify admin about audio
            await send_telegram_notification_enhanced(
                db=db, notification_type="audio_received",
                title="üéµ ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà",
                message=f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {profile_data['display_name']}\n‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤: {duration/1000:.1f} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ",
                user_id=user_id, priority=2,
                data={"message_id": message_id, "duration": duration}
            )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="audio_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_file_message(self, event: MessageEvent, db: AsyncSession,
                                line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle file messages with document analysis"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            message_id = event.message.id
            file_name = getattr(event.message, 'file_name', 'unknown_file')
            file_size = getattr(event.message, 'file_size', 0)
            
            # Save file message log
            await save_chat_to_history(
                db=db, user_id=user_id, message_type='user_file',
                message_content=f"‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå: {file_name} ({file_size} bytes)",
                session_id=f"file_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                extra_data={"message_id": message_id, "file_name": file_name, "file_size": file_size}
            )
            
            # Show loading animation
            await self._show_loading_animation(line_bot_api, user_id, 5)
            
            # Check file size and type
            if file_size > 10 * 1024 * 1024:  # 10MB limit
                error_response = "‚ùå ‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡πÄ‡∏Å‡∏¥‡∏ô 10MB)\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå"
                await line_bot_api.reply_message(
                    ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=error_response)])
                )
                return True
            
            # Check if it's a supported document type
            supported_extensions = ['.pdf', '.doc', '.docx', '.txt']
            file_extension = '.' + file_name.split('.')[-1].lower() if '.' in file_name else ''
            
            if file_extension not in supported_extensions:
                error_response = f"‚ùå ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå {file_extension} ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö\n\n‡∏£‡∏∞‡∏ö‡∏ö‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå: PDF, DOC, DOCX, TXT\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö"
                await line_bot_api.reply_message(
                    ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=error_response)])
                )
                return True
            
            try:
                # Download and analyze document (PDF only for now)
                if file_extension == '.pdf':
                    blob_api = await self._get_blob_api()
                    file_content = await blob_api.get_message_content(message_id=message_id)
                    
                    analysis_prompt = f"‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡∏£‡∏∏‡∏õ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Ç‡∏≠‡∏á‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠ {profile_data['display_name']} ‡πÇ‡∏î‡∏¢‡πÄ‡∏ô‡πâ‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç"
                    
                    ai_response = await document_understanding(file_content, analysis_prompt)
                    
                    response_text = f"üìÑ ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£: {file_name}\n\n{ai_response}"
                    
                else:
                    # Other document types - basic response
                    response_text = f"üìÑ ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå: {file_name}\n\n‡∏Ç‡∏ô‡∏≤‡∏î: {file_size:,} bytes\n‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó: {file_extension.upper()}\n\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà'"
                
                await line_bot_api.reply_message(
                    ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
                )
                
                # Save response
                await save_chat_to_history(
                    db=db, user_id=user_id, message_type='ai_document_analysis',
                    message_content=response_text,
                    session_id=f"file_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    extra_data={"message_id": message_id, "file_name": file_name, "ai_powered": True}
                )
                
                # Notify admin
                await send_telegram_notification_enhanced(
                    db=db, notification_type="document_received",
                    title="üìÑ ‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà",
                    message=f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {profile_data['display_name']}\n‡πÑ‡∏ü‡∏•‡πå: {file_name}\n‡∏Ç‡∏ô‡∏≤‡∏î: {file_size:,} bytes",
                    user_id=user_id, priority=2,
                    data={"message_id": message_id, "file_name": file_name, "file_size": file_size}
                )
                
            except Exception as e:
                error_response = "‚ùå ‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà"
                await line_bot_api.reply_message(
                    ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=error_response)])
                )
                
                await log_system_event(
                    db=db, level="error", category="gemini", subcategory="document_analysis_failed",
                    message=f"Document analysis failed: {str(e)}", user_id=user_id
                )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="file_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_location_message(self, event: MessageEvent, db: AsyncSession,
                                    line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle location messages with geographic context"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            
            latitude = event.message.latitude
            longitude = event.message.longitude
            address = getattr(event.message, 'address', '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà')
            title = getattr(event.message, 'title', '‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á')
            
            # Save location message log
            await save_chat_to_history(
                db=db, user_id=user_id, message_type='user_location',
                message_content=f"‡∏™‡πà‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á: {title} ({latitude}, {longitude})",
                session_id=f"location_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                extra_data={
                    "latitude": latitude, "longitude": longitude, 
                    "address": address, "title": title
                }
            )
            
            # Create location response with context
            response_text = f"üìç ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏•‡πâ‡∏ß!\n\n"
            response_text += f"üè∑Ô∏è ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà: {title}\n"
            response_text += f"üìß ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà: {address}\n"
            response_text += f"üó∫Ô∏è ‡∏û‡∏¥‡∏Å‡∏±‡∏î: {latitude:.6f}, {longitude:.6f}\n\n"
            
            # Add helpful suggestions based on location
            if "hospital" in title.lower() or "‡πÇ‡∏£‡∏á‡∏û‡∏¢‡∏≤‡∏ö‡∏≤‡∏•" in title:
                response_text += "üè• ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏û‡∏¢‡∏≤‡∏ö‡∏≤‡∏• ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏û‡∏ó‡∏¢‡πå ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏≠‡∏ö‡∏ñ‡∏≤‡∏°‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÑ‡∏î‡πâ"
            elif "school" in title.lower() or "‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô" in title or "‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢" in title:
                response_text += "üè´ ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏ñ‡∏≤‡∏ö‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤ ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏≠‡∏ö‡∏ñ‡∏≤‡∏°‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÑ‡∏î‡πâ"
            elif "government" in title.lower() or "‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£" in title or "‡πÄ‡∏ó‡∏®‡∏ö‡∏≤‡∏•" in title:
                response_text += "üèõÔ∏è ‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£ ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏†‡∏≤‡∏Ñ‡∏£‡∏±‡∏ê ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏≠‡∏ö‡∏ñ‡∏≤‡∏°‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÑ‡∏î‡πâ"
            else:
                response_text += "‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏≠‡∏ö‡∏ñ‡∏≤‡∏°‡πÑ‡∏î‡πâ‡πÄ‡∏™‡∏°‡∏≠"
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
            )
            
            # Notify admin about location sharing
            await send_telegram_notification_enhanced(
                db=db, notification_type="location_shared",
                title="üìç ‡πÅ‡∏ä‡∏£‡πå‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á",
                message=f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {profile_data['display_name']}\n‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà: {title}\n‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà: {address}",
                user_id=user_id, priority=2,
                data={"latitude": latitude, "longitude": longitude, "address": address}
            )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="location_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_sticker_message(self, event: MessageEvent, db: AsyncSession,
                                   line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle sticker messages with emotional context"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            
            package_id = event.message.package_id
            sticker_id = event.message.sticker_id
            
            # Save sticker message log
            await save_chat_to_history(
                db=db, user_id=user_id, message_type='user_sticker',
                message_content=f"‡∏™‡πà‡∏á‡∏™‡∏ï‡∏¥‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå (Package: {package_id}, ID: {sticker_id})",
                session_id=f"sticker_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                extra_data={"package_id": package_id, "sticker_id": sticker_id}
            )
            
            # Analyze sticker emotion and respond appropriately
            sticker_response = await self._analyze_sticker_emotion(package_id, sticker_id)
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=sticker_response)])
            )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="sticker_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_postback_message(self, event: PostbackEvent, db: AsyncSession,
                                    line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle postback events from interactive elements"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            postback_data = event.postback.data
            
            # Parse postback data
            try:
                data_dict = json.loads(postback_data) if postback_data.startswith('{') else {"action": postback_data}
            except:
                data_dict = {"action": postback_data}
            
            # Save postback event
            await save_chat_to_history(
                db=db, user_id=user_id, message_type='user_postback',
                message_content=f"Postback: {postback_data}",
                session_id=f"postback_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                extra_data=data_dict
            )
            
            # Handle different postback actions
            response_text = await self._handle_postback_action(data_dict, profile_data)
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
            )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="postback_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_quick_reply_message(self, event: MessageEvent, db: AsyncSession,
                                       line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle quick reply responses"""
        # Quick replies are processed as regular text messages with postback data
        return await self.handle_text_message(event, db, line_bot_api, profile_data)

    async def handle_imagemap_message(self, event: MessageEvent, db: AsyncSession,
                                    line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle imagemap interactive messages"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            
            response_text = "üó∫Ô∏è ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Imagemap!\n\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà"
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
            )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="imagemap_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_template_message(self, event: MessageEvent, db: AsyncSession,
                                    line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle template message interactions"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            
            response_text = "üìã ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏ó‡∏°‡πÄ‡∏û‡∏•‡∏ï!\n\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡πÑ‡∏ß‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°"
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
            )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="template_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_flex_message(self, event: MessageEvent, db: AsyncSession,
                                line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle Flex Message interactions"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            
            response_text = "‚ú® ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Flex Message!\n\n‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÅ‡∏à‡πâ‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏™‡∏°‡∏≠"
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
            )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="flex_handler_error", message=str(e), user_id=user_id
            )
            return False

    async def handle_carousel_flex_message(self, event: MessageEvent, db: AsyncSession,
                                         line_bot_api: AsyncMessagingApi, profile_data: Dict) -> bool:
        """Handle Carousel Flex Message interactions"""
        try:
            user_id = event.source.user_id
            reply_token = event.reply_token
            
            response_text = "üé† ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Carousel!\n\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÉ‡∏ô‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡πÉ‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏ ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢"
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
            )
            
            return True
            
        except Exception as e:
            await log_system_event(
                db=db, level="error", category="message_handler",
                subcategory="carousel_handler_error", message=str(e), user_id=user_id
            )
            return False

    # Helper methods
    
    async def _show_loading_animation(self, line_bot_api: AsyncMessagingApi, user_id: str, seconds: int = 3):
        """Enhanced loading animation with debug info and fallbacks"""
        try:
            from app.services.line_loading_helper import (
                show_enhanced_loading_animation, 
                print_loading_animation_debug
            )
            
            print(f"üîÑ Showing loading animation for user {user_id} ({seconds}s)")
            success = await show_enhanced_loading_animation(
                line_bot_api=line_bot_api,
                user_id=user_id, 
                context="‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•",
                seconds=seconds
            )
            
            # Debug information
            if not success:
                print_loading_animation_debug(user_id, success)
                print(f"‚ö†Ô∏è Loading animation failed for user {user_id}, continuing without it")
            else:
                print(f"‚úÖ Loading animation shown successfully for user {user_id}")
                
        except Exception as e:
            print(f"‚ùå Loading animation error for user {user_id}: {e}")
            # Continue without loading animation - don't let this break the flow
    
    async def _get_blob_api(self) -> AsyncMessagingApiBlob:
        """Get blob API client for downloading content"""
        from linebot.v3.messaging import AsyncApiClient, Configuration
        configuration = Configuration(access_token=settings.LINE_CHANNEL_ACCESS_TOKEN)
        async_api_client = AsyncApiClient(configuration)
        return AsyncMessagingApiBlob(async_api_client)
    
    def _enhance_text_prompt(self, message: str, profile_data: Dict) -> str:
        """Enhance text prompt with user context"""
        enhanced = f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠ {profile_data['display_name']} ‡∏ñ‡∏≤‡∏°‡∏ß‡πà‡∏≤: {message}\n\n"
        enhanced += "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏≠‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏∏‡∏†‡∏≤‡∏û‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ ‡πÅ‡∏•‡∏∞‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå"
        return enhanced
    
    async def _handle_special_commands(self, message: str, event: MessageEvent, 
                                     db: AsyncSession, line_bot_api: AsyncMessagingApi, 
                                     profile_data: Dict) -> bool:
        """Handle special commands like admin request"""
        if any(keyword in message.lower() for keyword in ['‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà', '‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô', 'admin', 'help']):
            user_id = event.source.user_id
            reply_token = event.reply_token
            
            # Switch to live chat mode
            from app.db.crud import set_live_chat_status
            await set_live_chat_status(db, user_id, True, profile_data['display_name'], profile_data['picture_url'])
            
            response_text = "‚úÖ ‡∏£‡∏±‡∏ö‡∏ó‡∏£‡∏≤‡∏ö ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏≠‡∏ô‡∏™‡∏≤‡∏¢‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà ‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ô‡πÑ‡∏°‡πà‡∏ä‡πâ‡∏≤"
            
            await line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
            )
            
            # Notify admin
            await send_telegram_notification_enhanced(
                db=db, notification_type="chat_request",
                title="üö® ‡∏Ç‡∏≠‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà",
                message=f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {profile_data['display_name']}\n‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: {message}",
                user_id=user_id, priority=3,
                data={"trigger_message": message, "profile": profile_data}
            )
            
            return True
        
        return False
    
    async def _analyze_sticker_emotion(self, package_id: str, sticker_id: str) -> str:
        """Analyze sticker emotion and provide appropriate response"""
        # Basic sticker emotion mapping
        happy_stickers = ['1', '2', '3', '4', '144']  # Common happy sticker IDs
        sad_stickers = ['5', '6', '7', '8']  # Common sad sticker IDs
        love_stickers = ['9', '10', '11', '12']  # Common love sticker IDs
        
        if sticker_id in happy_stickers:
            return "üòä ‡∏î‡∏µ‡πÉ‡∏à‡∏ó‡∏µ‡πà‡πÄ‡∏´‡πá‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç! ‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏´‡∏°‡∏Ñ‡∏∞"
        elif sticker_id in sad_stickers:
            return "üòî ‡πÄ‡∏´‡πá‡∏ô‡πÉ‡∏à‡∏Ñ‡∏∏‡∏ì‡∏ô‡∏∞‡∏Ñ‡∏∞ ‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏´‡∏° ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà"
        elif sticker_id in love_stickers:
            return "üíñ ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏°‡∏≤‡∏Å‡∏Ñ‡πà‡∏∞! ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏Ñ‡∏∏‡∏ì"
        else:
            return "üòÑ ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏ï‡∏¥‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡∏ô‡πà‡∏≤‡∏£‡∏±‡∏Å! ‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏´‡∏°‡∏Ñ‡∏∞"
    
    async def _handle_postback_action(self, data: Dict, profile_data: Dict) -> str:
        """Handle different postback actions"""
        action = data.get('action', 'unknown')
        
        if action == 'view_services':
            return "üìã ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤:\n\n1. ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ\n2. ‡πÅ‡∏ö‡∏ö‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏Ñ‡∏≥‡∏Ç‡∏≠\n3. ‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£"
        elif action == 'contact_admin':
            return "üìû ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà..."
        elif action == 'help':
            return "‚ùì ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:\n\n- ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏° ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ñ‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•\n- ‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå\n- ‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö\n- ‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ô"
        else:
            return f"‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô {action} ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÅ‡∏à‡πâ‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏™‡∏°‡∏≠"
    
    async def _handle_unsupported_message(self, event: MessageEvent, db: AsyncSession,
                                        line_bot_api: AsyncMessagingApi, profile_data: Dict, message_type: str):
        """Handle unsupported message types"""
        user_id = event.source.user_id
        reply_token = event.reply_token
        
        response_text = f"üì± ‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡∏£‡∏∞‡∏ö‡∏ö‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó '{message_type}' ‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ\n\n"
        response_text += "üìù ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ:\n"
        response_text += "‚Ä¢ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤\n"
        response_text += "‚Ä¢ ‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û\n" 
        response_text += "‚Ä¢ ‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå PDF\n"
        response_text += "‚Ä¢ ‡πÅ‡∏ä‡∏£‡πå‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á\n"
        response_text += "‚Ä¢ ‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ô"
        
        await line_bot_api.reply_message(
            ReplyMessageRequest(reply_token=reply_token, messages=[TextMessage(text=response_text)])
        )
        
        await log_system_event(
            db=db, level="warning", category="message_handler",
            subcategory="unsupported_type",
            message=f"Unsupported message type: {message_type}",
            user_id=user_id
        )

# Global message handler instance
message_handler = MessageHandler()

# Export main function for integration
async def process_line_message(event: MessageEvent, db: AsyncSession, line_bot_api: AsyncMessagingApi) -> bool:
    """
    Main entry point for processing LINE messages
    
    Args:
        event: LINE message event
        db: Database session
        line_bot_api: LINE messaging API client
        
    Returns:
        bool: Processing success status
    """
    return await message_handler.process_message(event, db, line_bot_api)